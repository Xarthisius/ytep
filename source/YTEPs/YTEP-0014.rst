YTEP-0014: YTArray
==================

Abstract
--------

Created: March 12, 2013
Author: Casey W. Stark

We propose a new data structure called YTArray. YTArray acts as the new data
array type in yt, overloading the usual numpy.ndarray. YTArray is a subclass of
numpy.ndarray that tracks units in all calculations. We started this work
during the yt dev workshop 2013 in Santa Cruz.

Status
------

In Progress

The details of the final design are still up for discussion, but we have a
working (not crashing) implementation for now.

Project Management Links
------------------------

This work is ongoing in Casey's 3.0 fork:
https://bitbucket.org/caseywstark/yt-3.0

All members of the yt-dev 2013 unit breakout group have contributed to this
fork: Andrew Myers, Anna Rosen, Britton Smith, Casey Stark, Matthew Turk,
and Nathan Goldbaum.

Ask Casey for write permission if you want to contribute.

Detailed Description
--------------------

Background
++++++++++

Currently, yt users have to be very careful about their units and conversions.
When a user adds a derived field, they must provide a convert function that
handles the conversion factor between the units returned by the data function
and the units they specify in the field definition. Users must also provide
a custom LaTeX string for the units kwarg. Here's an example:

.. code-block:: python

    def _convert_particle_mass_msun(data):
        return 1.0 / 1.989e33
    def _particle_mass_m_sun(field, data):
        return data["particle_mass"]
    add_field("ParticleMassMsun", function=_particle_mass_m_sun,
              validators=[ValidateSpatial(0), ValidateDataField("particle_mass")],
              particle_type=True, convert_function=_convert_particle_mass_msun,
              take_log=True, units=r"\rm{M_{\odot}}")

Solution
++++++++

YTArray uses the new symbolic units functionality to track units in all
calculations and handles any conversion. YTArray has an additional attribute
`units` which is a Unit object and describes the units the YTArray data is in.

In order to track the units, we need to overload the YTArray operations so the
units attribute is set appropriately and then passed off to the same numpy
operation.

One complication is that `array1 * array2` is not the only way to perform
an operation on a numpy array. There is also `np.multiply(array1, array2)`. In
the second case YTArray.__mul__ is not called! To catch this case, we also
overload the __array_wrap__ method, as described in numpy's subclassing
documentation http://docs.scipy.org/doc/numpy/user/basics.subclassing.html.

Finally, we create a _ufunc_registry dictionary in YTArray that maps ufuncs to
functions that handle unit conversion for that array. For instance, the entry
for the add ufunc is `add: preserve_unit`, where the preserve_unit function
is:

.. code-block:: python

    def preserve_unit(unit1, unit2):
        return unit1

The function has two arguments because there are two arrays in the add op.

.. code-block:: python

    def __mul__(self, right_object):
        """
        Multiply this YTArray by the object on the right of the `*` operator.
        The unit objects handle being multiplied.

        """
        return YTArray(super(YTArray, self).__mul__(right_object))

    ...


Stumbling Points
++++++++++++++++

This is an extremely invasive change and we must be careful about how we
replace all numpy operations.

Backwards Compatibility
-----------------------

The YTArray changes alone should not break user scripts. Because YTArray is
an ndarray subclass, it should act the same under any operations. The only
issue that should come up are unit changes related to the field changes
proposed in YTEP-0004, since it will be impractical to decouple these changes.
