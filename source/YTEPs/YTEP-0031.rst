.. _ytep-0031:

YTEP-0031: Removing the global octree mesh for particle data
============================================================

Abstract
--------

| Created: February 9 2017
| Author: Nathan Goldbaum, Meagan Lang, Matthew Turk

This summarizes the effort to remove the global octree mesh to current used to
index particle data. This effort can be separated into a low-level component and
a high-level user-facing component. The low-level effort refactors particle I/O
and data selection to make use of an indexing scheme based on compressed morton
bitmaps. This approach dramatically improves memory usage and improves scaling
for large particle datasets. The second high-level effort is a reworking of the
yt user interface for particle and SPH data. This means that data object
selections for fields that are now defined on the global octree mesh instead
return field data at particle locations. For SPH data, visualizations of slices
and projections are done in the image plane, making use of the "scatter"
approach by smoothing SPH data directly onto images, making use of either a
volumetric or projected SPH smoothing kernel. Fully local derived fields are
calculated using yt's existing field definitions. Fields that need spatial
derivatives are implemented using the SPH formalism and are also evaluated at
the particle locations. Alltogether these changes allow for improved performance
and scaling, and allow users to access, analyze, and visualize particle field
data for SPH simulations in a more straightforward fashion. While we do not
propose substantial API changes, these changes to yt's field system for particle
data imply substantial changes to the *meaning* of yt's data selection
system. We discuss the implications of these backward incompatible changes and
how we intend to document and manage them in a way that is minimally disruptive
to users.

Status
------

In Progress. The implementation is mostly finished, although there are a few
features that still need to be implemented.

Project Management Links
------------------------

The code can be found in pull request 2382:

https://bitbucket.org/yt_analysis/yt/pull-requests/2382

The C++ compressed bitmap implementation we intend to vendor into yt:

https://github.com/lemire/EWAHBoolArray

Detailed Description
--------------------

Background
**********

Currently yt indexes particle data via a global in-memory octree mesh. This
approach initially made it much easier to support particle data by employing
existing infrastructure in yt for analyzing and visualizing octree
meshes. Unfortunately, this approach also presented challenges for improving the
scalability and performance of yt. User feedback and developer input have also
indicated a desire to present users with more access to the fundamental particle
data rather than data interpolated onto an octree. Rather than using the global
octree mesh to index particle data, we instead store particle positions via
compressed Morton bitmaps. By calculating morton bitmaps for selector objects,
we can quickly establish which I/O chunks provide particles at a given location
in the dataset's domain. Since compressed bitmaps are much more memory efficient
than the existing global octree, this approach enables visualization and
analysis on much larger particle datasets without the need for excessive memory
requirements.

Implementation
**************

Morton Bitmap Index
+++++++++++++++++++

The generated index serves to map how the domain is populated by particles in
datasets split across multiple files. This way, spatial queries can skip files
that do not contain particles in the selected part of the domain. The files are
mapped by storing two nested Morton indices for each particle in a
dataset. Rather than storing the indices in plaintext, we make use of an EWAH
compressed boolean array bitmap. Given a domain with known boundaries in each
dimension, a 3-dimension position can be described by a single integer `Morton
index <https://en.wikipedia.org/wiki/Z-order_curve>`_ by

1. Dividing the domain into ``2^index_order1`` cells in each dimension with
   widths ``ddx = domain_width_x/(2^index_order1)``.
#. Determining the 3 integers specifying the cell that contains the 3D
   position (e.g. ``x/ddx``).
#. Combine the 3 integers into a single integer by alternating bits from each
   dimension.

These indices can be stored as either integers or in boolean masks. In the case
of the mask, an array of zeroed bits is created with a length equal to the
maximum possible index for the chosen value of ``index_order1``. Then the bits
for the indices present are set to one. To save space, boolean masks in the form
of bitmaps can then be compressed further using the `Enhanced Word-Aligned
Hybrid (EWAH) bitmap compression algorithm
<https://doi.org/10.1145/1458432.1458434>`_. In practice, we make use of a
vendored version of `EWAHBoolArray <https://github.com/lemire/EWAHBoolArray>`_,
a C++ EWAH bitmask implementation available under the Apache v2 license.

One bitmap is created for each file. If an index is present in more than one
file’s bitmap, this represents a collision and decreases the likelihood that
the bitmap can be used to exclude files during spatial queries. This is unlikely
if the particles are well partitioned between the files according to a domain
decomposition scheme at the chosen order, but this is not generally true of
particle datasets produced by astrophysical simulations. In these cases, it
is better to create a more refined index.

Using a larger ``index_order1`` increases the refinement of the index, but also 
increases both the memory required to store the indices and the time required
to query them for EWAH bitmaps. To combat this, we include a second refined
index within those cells that have indices in multiple files’ bitmaps for the 
coarse index. For each particle with a coarse index that collides with another
file, a second refined Morton index is creating by following the same procedure 
as for the coarse index, but exchanging the domain boundaries for the boundaries
of the coarse index cell. The refined index for each file is then stored in a 
EWAH bitmap for each coarse cell with a collision.

The coarse and refined indices are generated in two separate I/O passes over the
entire dataset. To generate the coarse index, the coordinates of all particles,
as well as the softening lengths for SPH particles, are read in from each
file. For each particle, we then compute the Morton index corresponding to the
particles position within the domain. This index, ``mi`` is then used to set the
``mi``\ th element in a boolean mask for the file to 1. If the particle is an
SPH particle, neighboring indices with cells that overlap a sphere with a radius
equal to the particle’s softening length and centered on the particle are also
set to 1.

Once a coarse boolean mask is obtained for each file, the masks are stored in
a set of EWAH compressed bitmaps (``ewah_bool_array`` Cython extension 
classes). Using logical boolean operations, we then identify those indices 
that are set to 1 in more than one file’s mask (the collisions). 

During a second I/O pass over the entire dataset, refined indices are created
for those particles with colliding coarse indices. Both the coarse and refined
indices are stored in an array for each file. One a file has been completely
read in, those indices are sorted and used to create a map from coarse indices
to EWAH compressed bitmaps. This is done because entries in EWAH compressed 
bitmaps must be set in order.

The Morton bitmap index is created for each particle dataset upon its first
ingestion into yt and saved to a sidecar file. At all future ingestions of the
dataset into yt, the index will be loaded from the sidecar file. Indexes are
managed through the Cython extension class ``ParticleBitmap`` (defined in
``yt/geometry/particle_oct_container.pyx``), which is exposed to the user
visible yt API via the ``regions`` attribute of the ``ParticleIndex`` class
(e.g. ``ds.index.regions``). The ``ParticleBitmap`` class generates EWAH bitmaps
via the ``BoolArrayCollection`` Cython extension object (defined in
``yt/utilities/lib/ewah_bool_wrap.pyx``), which wraps the underlying
``EWAHBoolArray`` C++ library.


Data Selection and Changes to the Selector API
++++++++++++++++++++++++++++++++++++++++++++++

Visualization of Slices and Projection
++++++++++++++++++++++++++++++++++++++

SPH Fields
++++++++++

Testing
+++++++

Open Questions
--------------

The Projection Data Object
**************************

Cut Regions
***********

Global Octree or Octree Subset Data Object
******************************************

Volume Rendering
****************

Community engagement
********************

yt 4.0?
*******

Backwards Compatibility
-----------------------

